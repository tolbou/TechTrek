## group_by

Rubyのgroup_byメソッドを使うととても便利です。

group_byメソッドは、要素をグループ分けします。

ブロック引数に各要素を入れてブロックを繰り返し、その戻り値が同じ要素をそれぞれ集めるというメソッドです。

以下のような配列があるとします

```
ary = [1, 1, 1, 2, 3, 3]
```

この配列を要素別にまとめてみようと思います。

```
p ary.group_by(&:itself)
```

とすると

```
{1=>[1, 1, 1], 2=>[2], 3=>[3, 3]}
```

のような結果となります。

(ただし、このobject.itselfはRuby2.2で公開されたものです

ので、Ruby2.2以降でないと使えません。)

次にこちらの要素ごと数えてそれをハッシュで返すようにすれば良いので、mapメソッドとcountメソッドを付け加えてみます。

そして最終的にハッシュで表示したいのでto_hashを加えます。

```
p ary.group_by(&:itself).map{ |key value| [key, value.count] }.to_h
```

```
{1=>3, 2=>1, 3=>2}
```

のようになり、

key とそのkeyの数を表示することができるようになりましたね!!

`group_by`メソッドは、RubyのEnumerableモジュールで定義されているメソッドの1つで、コレクションの要素を指定されたブロックでグループ化するためのメソッドです。

具体的には、コレクション内の各要素をブロックに渡して得られた戻り値をキーとして、そのキーに対応する要素の配列を値とした新しいハッシュを返します。

つまり、キーでグループ化されたハッシュを作成することができます。

## group_byメソッドの使い方

`group_by`メソッドは、以下のように使用します。

`grouped = collection.group_by { |element| block }`

`collection`は配列やハッシュなどの要素を持つオブジェクトであり、`element` は要素を表します。

`element`には、`collection`の要素が順番に渡されます。

`block`には、各要素をグループ化するためのルールを指定します。

たとえば`bolck`には`element.key`のような指定ができます。

`key` は、要素をグループ化するための条件を表しており、この条件に基づいて`group_by` メソッドはグループごとに新しいハッシュを作成し、`grouped` 変数に代入します。

### 文字列の長さでグループ化する方法

例えば、以下のような配列があるとします。

`fruits = ['apple', 'banana', 'orange', 'peach', 'grape']`

この配列を文字列の長さでグループ化する場合、以下のように`group_by`メソッドを使うことができます。

`grouped_fruits = fruits.group_by { |fruit| fruit.length }`

これにより、以下のようなハッシュが返されます。

`{
  5 => ['apple',　'peach', 'grape'],
  6 => ['banana', 'orange']
}`

このように、`group_by`メソッドを使用すると、コレクション内の要素を簡単にグループ化できます。

### 偶数と奇数でグループ化する方法

例えば、以下のような配列を考えます。

`numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]`

この配列を、偶数と奇数でグループ化することを考えます。その場合、以下のように`group_by`メソッドを使うことができます。

`grouped_numbers = numbers.group_by { |n| n.even? }`

この場合、`grouped_numbers`は以下のようになります。

`{ false => [1, 3, 5, 7, 9], true => [2, 4, 6, 8, 10] }`

これは、偶数と奇数でグループ化されたハッシュが返されていることを示しています。

`group_by`メソッドに渡されたブロックで、各数値が偶数か奇数かを判定してグループ化しています。

### Hashのキーでグループ化する方法

例えば、以下のようなコードを実行すると、`users`配列を`age`プロパティでグループ化したハッシュを取得できます。

`users = [
  { name: 'Alice', age: 25 },
  { name: 'Bob', age: 30 },
  { name: 'Charlie', age: 25 },
  { name: 'Dave', age: 35 }
]

grouped_age = users.group_by { |user| user[:age] }`

これにより、以下のようなハッシュが返されます。

`{
  25 => [
    { name: 'Alice', age: 25 },
    { name: 'Charlie', age: 25 }
  ],
  30 => [
    { name: 'Bob', age: 30 }
  ],
  35 => [
    { name: 'Dave', age: 35 }
  ]
}`

### 複数条件を指定してグループ化する方法

`group_by` メソッドでは、複数の条件を指定することもできます。

`fruits = ['apple', 'banana', 'orange', 'peach', 'grape']

grouped_fruits = fruits.group_by { |fruit| [fruit.length, fruit.start_with?('a')] }`

条件を配列で`[fruit.length, fruit.start_with?('a')]` のように複数指定して、要素をグループ化しています。

この配列は、要素の文字列の長さと、文字列が 「a」 で始まるかどうかの条件で、要素をグループ化しています。

grouped_fruits には、以下のようなグループが含まれるハッシュが返されます。

`{
  [5, true] => ['apple'],
  [5, false] => ['peach', 'grape'],
  [6, false] => ['banana', 'orange']
}`

このように、複数条件を指定することで、複雑なグループ化が可能になります。

## 注意点

`group_by` メソッドは、グループごとに配列を作成するため、要素数が多い場合はメモリの消費量が大きくなる可能性があります。

そのため、処理する要素数に注意が必要です。

また、条件によってグループ化した要素が大量に存在する場合は、グループごとの配列の要素数が多くなり、処理が遅くなる可能性があるので注意しましょう。

## まとめ

• group_by メソッドは、配列やハッシュの要素を条件に基づいてグループ化し、グループごとに新しいハッシュを作成する
• 配列だけでなく、ハッシュ（Hash）に対しても使用できる
• 複数の条件を指定することができる
• 処理する要素数やグループごとの要素数に注意する